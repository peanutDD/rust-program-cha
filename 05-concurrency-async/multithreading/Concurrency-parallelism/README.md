# Rust 并发与并行深度教程

本教程全面深入地分析 Rust 中的并发与并行编程，基于 [course.rs](https://course.rs/advance/concurrency-with-threads/concurrency-parallelism.html) 的内容进行扩展和实践。

## 📚 教程内容概览

### 1. 并发与并行概念深度分析
- **并发 vs 并行的核心区别**：理解概念差异和实际应用场景
- **CPU 核心与线程关系**：系统资源与并发能力的关系
- **Rust 线程模型**：1:1 线程模型的特点和优势
- **操作系统调度机制**：线程调度和上下文切换

### 2. 线程基础与生命周期管理
- **基本线程创建**：`thread::spawn` 的使用方法
- **move 语义**：所有权转移在多线程中的应用
- **线程生命周期管理**：`JoinHandle` 和线程同步
- **线程构建器**：自定义线程名称和栈大小

### 3. 共享状态并发编程
- **Mutex 互斥锁**：基础使用和锁的生命周期
- **Arc 原子引用计数**：多线程间共享数据
- **RwLock 读写锁**：读多写少场景的优化
- **死锁预防策略**：锁排序和超时机制

### 4. 消息传递并发模式
- **基本 channel**：单生产者单消费者模式
- **多生产者单消费者**：`mpsc` 的实际应用
- **同步 channel**：有界队列和背压控制
- **异步通信模式**：非阻塞消息传递

### 5. Send 和 Sync 特征深度解析
- **Send 特征**：类型在线程间安全转移所有权的标记
- **Sync 特征**：类型可以安全共享引用的标记
- **自动实现规则**：编译器如何推导线程安全性
- **非线程安全类型**：`Rc<T>` 和 `RefCell<T>` 的限制

### 6. 原子操作与无锁编程
- **原子类型**：`AtomicUsize`、`AtomicBool` 等的使用
- **内存顺序**：`Ordering` 枚举和内存模型
- **Compare-and-Swap**：CAS 操作的原理和应用
- **无锁数据结构**：高性能并发编程技术

### 7. 实际应用案例
- **生产者-消费者模式**：经典并发设计模式
- **线程池模式**：工作线程管理和任务分发
- **并发数据结构**：线程安全的哈希表实现
- **性能优化技巧**：减少锁竞争的策略

### 8. 性能分析与优化
- **锁竞争分析**：高竞争 vs 低竞争场景对比
- **原子操作 vs 锁**：性能基准测试
- **并发性能基准**：加速比和并行效率计算
- **性能调优指南**：实际项目中的优化策略

## 🚀 运行教程

### 前置要求
- Rust 1.70+ 
- Cargo 包管理器

### 运行完整教程
```bash
# 进入项目目录
cd Concurrency-parallelism

# 运行教程（包含所有演示）
cargo run

# 运行测试用例
cargo test

# 运行特定测试
cargo test test_thread_safety
cargo test test_message_passing
cargo test test_atomic_operations
cargo test test_rwlock_functionality
```

### 性能基准测试
```bash
# 运行优化版本进行性能测试
cargo run --release
```

## 📊 教程特色

### 🔍 深度分析
- **理论与实践结合**：每个概念都配有实际代码演示
- **性能对比**：量化分析不同并发方案的性能差异
- **最佳实践**：总结实际项目中的经验和教训

### 🛡️ 安全第一
- **类型系统保证**：展示 Rust 如何在编译时防止数据竞争
- **内存安全**：无需担心悬垂指针和内存泄漏
- **死锁预防**：提供实用的死锁避免策略

### 📈 性能优化
- **基准测试**：量化不同方案的性能表现
- **优化技巧**：减少锁竞争和提高并发度
- **实际案例**：生产环境中的性能调优经验

### 🧪 全面测试
- **单元测试**：验证每个并发组件的正确性
- **集成测试**：测试复杂并发场景
- **压力测试**：验证高负载下的稳定性

## 🎯 学习目标

完成本教程后，你将能够：

1. **理解并发与并行的本质区别**，选择合适的并发模型
2. **熟练使用 Rust 的线程 API**，管理线程生命周期
3. **掌握共享状态并发编程**，正确使用 `Mutex`、`Arc`、`RwLock`
4. **运用消息传递模式**，设计解耦的并发系统
5. **理解 Send 和 Sync 特征**，编写类型安全的并发代码
6. **使用原子操作**，实现高性能的无锁数据结构
7. **分析并发性能**，识别和解决性能瓶颈
8. **应用最佳实践**，避免常见的并发陷阱

## 🔧 高级主题

### 内存模型深入
- **Acquire-Release 语义**：内存顺序的实际应用
- **内存屏障**：硬件级别的同步机制
- **缓存一致性**：多核 CPU 的内存访问模式

### 异步编程预览
- **Future 和 async/await**：异步并发模型
- **Tokio 运行时**：异步任务调度
- **异步 vs 多线程**：选择合适的并发模型

### 系统级优化
- **NUMA 感知**：非统一内存访问的优化
- **CPU 亲和性**：线程绑定到特定核心
- **锁优化技术**：自旋锁、读写锁的高级用法

## 📖 参考资料

- [Rust 官方文档 - 并发](https://doc.rust-lang.org/book/ch16-00-concurrency.html)
- [course.rs - 并发与并行](https://course.rs/advance/concurrency-with-threads/concurrency-parallelism.html)
- [The Rustonomicon - 并发](https://doc.rust-lang.org/nomicon/concurrency.html)
- [Rust Atomics and Locks](https://marabos.nl/atomics/)

## 🤝 贡献

欢迎提交 Issue 和 Pull Request 来改进本教程！

## 📄 许可证

本教程采用 MIT 许可证。